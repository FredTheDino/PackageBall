mod Player

type Player = { p: Vec, v: Vec }

def rad : Real := 20.0

def pos : Player -> Vec : { p, v } = p

def vel : Player -> Vec : { p, v } = v

def new : Player := { p: { x: Render.width Unit.unit / 2.0, y: Render.height Unit.unit / 2.0 }, v: { x: 0.0, y: 0.0 }}

def input_to_vec : Input -> Vec : { left, right, up, down } =
  Vec.add
    (Vec.vec (Bool.iff left 1.0 0.0) (Bool.iff up 1.0 0.0) # Vec.mul (`1.0))
    (Vec.vec (Bool.iff right 1.0 0.0) (Bool.iff down 1.0 0.0))

def update : Real -> Input -> Player -> Player : dt input { p, v } = 
  { p: v
        # Vec.mul dt
        # Vec.add p
  , v: input_to_vec input
        # Vec.mul (dt * 2000.0)
        # Vec.add v
        # Vec.clamp 1000.0
        # Vec.mul (Math.pow 0.01 dt)
  }
  # clamp_inside

def box_collide
: Array Thing -> Player -> Player
: things player =
  Array.foldl (\thing { p, v } -> 
            match thing
            with Thing:Full { pos } if Circle.hit { p, r: Player.rad } { p: pos, r: Thing.rad thing } -> 
              { p, v: Vec.add v (let n = Vec.sub p pos in n) }
            with _ -> { p, v }
            end
        ) player things

def margin ::= rad * 1.5

def clamp_inside
  : Player -> Player
  : { p: { x, y }, v: { x: vx, y: vy } } = 
  let hix = (Render.width Unit.unit - margin)
  let hiy = (Render.height Unit.unit - margin)
  let lox = margin
  let loy = margin
  in
  { p: { x: Math.clamp lox hix x
       , y: Math.clamp loy hiy y }
  , v: { x: vx * Bool.to_real (((lox < x) && (vx < 0.0))
                               || ((0.0 < vx) && (x < hix)))
       , y: vy * Bool.to_real (((loy < y) && (vy < 0.0))
                               || ((0.0 < vy) && (y < hiy)))
       }
  }

def render
: Array Image -> Player -> Render
: assets { p: { x, y } } = 
  let img = Array.index_unsafe assets Asset.player
  let s = 2.0 * rad / Image.width img
  -- let r = 0.1 * angle thing
  in
  Render.color Render.white *> Render.image { x, y, r: 0.0, s } img

