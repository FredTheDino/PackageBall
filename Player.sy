mod Player

type Player = { p: Vec, v: Vec }

def rad : Real := 20.0

def pos : Player -> Vec : { p, v } = p

def vel : Player -> Vec : { p, v } = v

def new : Player := { p: { x:200, y:200 }, v: { x: 0, y: 0 }}

def input_to_vec : Input -> Vec : { left, right, up, down } =
  Vec.add
    (Vec.vec (Bool.iff left 1.0 0.0) (Bool.iff up 1.0 0.0) # Vec.mul (`1.0))
    (Vec.vec (Bool.iff right 1.0 0.0) (Bool.iff down 1.0 0.0))

def update : Real -> Input -> Player -> Player : dt input { p, v } = 
  { p: v
        # Vec.mul dt
        # Vec.add p
  , v: input_to_vec input
        # Vec.mul (dt * 2000.0)
        # Vec.add v
        # Vec.clamp 1000.0
        # Vec.mul (Math.pow 0.01 dt)
  }
  # clamp_inside

def margin ::= rad * 1.5

def clamp_inside
  : Player -> Player
  : { p: { x, y }, v: { x: vx, y: vy } } = 
  let hix = (Render.width Unit.unit - margin)
  let hiy = (Render.height Unit.unit - margin)
  let lox = margin
  let loy = margin
  in
  { p: { x: Math.clamp lox hix x
       , y: Math.clamp loy hiy y }
  , v: { x: vx * Bool.to_real (((lox < x) && (vx < 0.0))
                               || ((0.0 < vx) && (x < hix)))
       , y: vy * Bool.to_real (((loy < y) && (vy < 0.0))
                               || ((0.0 < vy) && (y < hiy)))
       }
  }

def render
: Player -> Render
: { p } = 
      Render.empty
      *> Render.circle p rad
      *> Render.color Render.white

