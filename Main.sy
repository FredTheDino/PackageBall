mod Main

type State = { shoe_spawn: Real, p : Player, things : Array Thing, score : Int, assets: Array Image }
type Input = { left: Bool, right: Bool, up: Bool, down: Bool, hit: Bool, restart: Bool, exit: Bool }

def get_restart : Input -> Bool : { restart } = restart
def get_exit : Input -> Bool : { exit } = exit
def get_hit : Input -> Bool : { hit } = hit

def spy : a -> a := foreign -[[
    function(x)
        print(x)
        return x
    end
]]-

def init : Int -> State : _ =
  { p: Player.new
  , shoe_spawn: 0.0
  , score: 0
  , things: []
  , assets: Asset.load_assets Unit.unit
  }

def spawn_rate ::= 0.01


def update : Real -> Input -> State -> State : dt input state@{ shoe_spawn, p, score, assets, things } =
  let updated_things = things # Array.map (Thing.update dt p (get_hit input) things)
  let boxes_to_spawn = 1.0 + (score / 500)
  let should_spawn_box =
      things
        # Array.count_if (\t -> match t with Thing:Box {pos: _, vel} -> 0.1 < Vec.len_sq vel with _ -> false end)
        # (\x -> ^x < boxes_to_spawn)
  let c = Array.count_if Thing.is_box things
  in
  match { r: get_restart input, e: get_exit input } 
  with { r: true, e: _ } ->
    init 0 
  with { r: _, e: true } ->
    Love.quit 0 state
  with _ if ^c < (boxes_to_spawn + 2.0) ->
    { p: p # Player.update dt input # Player.box_collide things
    , things: updated_things
                # Array.filter_map (\x -> x)
                # Bool.when
                  should_spawn_box
                  (\_ -> Array.prepend $ Thing.spawn_box things)
                # Bool.when
                  (shoe_spawn < 0.0)
                  (\_ -> Array.prepend $ Thing.spawn_shoe things)
    , score: Array.range 0 (Array.size things - 1)
                # Array.foldl (\i acc ->
                    match { a: Array.index_unsafe things i, b: Array.index_unsafe updated_things i }
                    with { a: Thing:Box _, b: Maybe:Just (Thing:Full _) } -> acc + 100
                    with _ -> acc
                    end
                ) score
    , shoe_spawn:
          Bool.iff
            (shoe_spawn < 0.0)
            (3.0 * Math.random Unit.unit)
            (shoe_spawn - dt)
    , assets
    }
  with _ ->
    { p, score, assets, things, shoe_spawn }
  end


def draw
: State -> Render
: { p, score, assets, things } =
  let pp = { x: 100.0, y: 200.0 }
  let r = 100.0
  in
  Render.empty
   *> Render.color Render.white
   *> background assets
   *> Player.render assets p
   *> Render.all (Thing.draw assets) things
   *> Render.printf ("Score: " ++ Int.to_string score) 0.0 0.0 300.0

def background : Array Image -> Render : assets =
  let img = Array.index_unsafe assets Asset.tile
  let size = Image.width img
  let needed_x = Real.floor (Render.width Unit.unit / size)
  let needed_y = Real.floor (Render.height Unit.unit / size)
  in
  Array.range 0 needed_x
    # Render.all (\x ->
      Array.range 0 needed_y
        # Render.all (\y ->
            Render.image { x: size * x + size / 2, y: size * y + size / 2, r: 0.0, s: 1.0 } img
        )
    )
