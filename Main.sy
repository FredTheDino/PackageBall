mod Main

type State = { p : Player, things : Array Thing, score : Int, assets: Array Image }
type Input = { left: Bool, right: Bool, up: Bool, down: Bool, restart: Bool, exit: Bool }

def get_restart : Input -> Bool : { restart } = restart
def get_exit : Input -> Bool : { exit } = exit

def spy : a -> a := foreign -[[
    function(x)
        print(x)
        return x
    end
]]-

def init : Int -> State : _ =
  { p: Player.new
  , score: 0
  , things: []
  , assets: Asset.load_assets Unit.unit
  }

def spawn_rate ::= 0.001


def update : Real -> Input -> State -> State : dt input state@{ p, score, assets, things } =
  let updated_things = things # Array.map (Thing.update dt p things)
  let should_spawn_box =
      !(things
        # Array.any (\t -> match t with Thing:Box {pos: _, vel} -> 0.1 < Vec.len_sq vel with _ -> false end))
  in
  match { r: get_restart input, e: get_exit input } 
  with { r: true, e: _ } ->
    init 0 
  with { r: _, e: true } ->
    Love.quit 0 state
  with _ ->
    { p: Player.update dt input p
    , things: updated_things
                # Array.filter_map (\x -> x)
                # Bool.iff
                  should_spawn_box
                  (Array.prepend $ Thing.spawn_box Unit.unit)
                  (\x -> x)
                # Bool.iff
                  (Math.random Unit.unit < spawn_rate)
                  (Array.prepend $ Thing.spawn_shoe Unit.unit)
                  (\x -> x)
    , score: Array.range 0 (Array.size things - 1)
                # Array.foldl (\i acc ->
                    match { a: Array.index_unsafe things i, b: Array.index_unsafe updated_things i }
                    with { a: Thing:Box _, b: Maybe:Just (Thing:Full _) } -> acc + 100
                    with _ -> acc
                    end
                ) score
    , assets
    }
  end


def draw
: State -> Render
: { p: p@{ p: xx }, score, assets, things } =
  let pp = { x: 100.0, y: 200.0 }
  let r = 100.0
  in
  Render.empty
   *> Render.color Render.white
   *> background assets
   *> Player.render p
   *> Render.all (Thing.draw assets) things
   *> Render.printf ("Score: " ++ Int.to_string score) 0.0 0.0 300.0

def background : Array Image -> Render : assets =
  let img = Array.index_unsafe assets Asset.tile
  let size = Image.width img
  let needed_x = Real.floor (Render.width Unit.unit / size)
  let needed_y = Real.floor (Render.height Unit.unit / size)
  in
  Array.range 0 needed_x
    # Render.all (\x ->
      Array.range 0 needed_y
        # Render.all (\y ->
            Render.image { x: size * x + size / 2, y: size * y + size / 2, r: 0.0, s: 1.0 } img
        )
    )
