mod Main

enum State
    = Game GameState
    | Menu Unit
type GameState = { shoe_spawn: Real, p : Player, things : Array Thing, score : Int, score_inc: Real, assets: Array Image }
type Input = { left: Bool, right: Bool, up: Bool, down: Bool, hit: Bool, restart: Bool, exit: Bool }

def get_restart : Input -> Bool : { restart } = restart
def get_exit : Input -> Bool : { exit } = exit
def get_hit : Input -> Bool : { hit } = hit

def spy : a -> a := foreign -[[
    function(x)
        print(x)
        return x
    end
]]-

def init : Int -> State : _ =
  State:Menu Unit.unit

def spawn_rate ::= 0.01

def update : Real -> Input -> State -> State : dt input state =
    match state
    with State:Game game_state -> update_game dt input game_state
    with State:Menu _ ->
        match get_hit input
        with true ->
            State:Game
              { p: Player.new
              , shoe_spawn: 0.0
              , score: 0
              , things: []
              , score_inc: 0.0
              , assets: ~Asset.load_assets
              }
        with false ->
            State:Menu Unit.unit
        end
    end

def update_game : Real -> Input -> GameState -> State : dt input state@{ shoe_spawn, p, score, assets, things, score_inc } =
  let updated_things = things # Array.map (Thing.update dt p (get_hit input) things)
  let boxes_to_spawn = 1.0 + (score / 500)
  let should_spawn_box =
      things
        # Array.count_if (\t -> match t with Thing:Box {pos: _, vel} -> 0.1 < Vec.len_sq vel with _ -> false end)
        # (\x -> ^x < boxes_to_spawn)
  let c = Array.count_if Thing.is_box things
  let new_score = Array.range 0 (Array.size things - 1)
                # Array.foldl (\i acc ->
                    match { a: Array.index_unsafe things i, b: Array.index_unsafe updated_things i }
                    with { a: Thing:Box _, b: Maybe:Just (Thing:Full _) } -> acc + 100
                    with _ -> acc
                    end
                ) score
  in
  match { r: get_restart input, e: get_exit input } 
  with { r: true, e: _ } ->
    init 0 
  with { r: _, e: true } ->
    Love.quit 0 (State:Game state)
  with _ if ^c < (boxes_to_spawn + 2.0) ->
    State:Game
    { p: p # Player.update dt input # Player.box_collide things
    , things: updated_things
                # Array.filter_map (\x -> x)
                # Bool.when
                  should_spawn_box
                  (\_ -> Array.prepend $ Thing.spawn_box things)
                # Bool.when
                  (shoe_spawn < 0.0)
                  (\_ -> Array.prepend $ Thing.spawn_shoe things)
    , score: new_score
    , shoe_spawn:
          Bool.iff
            (shoe_spawn < 0.0)
            (3.0 * ~Math.random)
            (shoe_spawn - dt)
    , assets
    , score_inc
    }
  with _ ->
    State:Game { p, score, assets, things, shoe_spawn, score_inc }
  end

def draw
: State -> Render
: state =
    match state
    with State:Game game_state -> draw_game game_state
    with State:Menu _ -> draw_menu
    end

def draw_game
: GameState -> Render
: { p, score, score_inc, assets, things } =
  let pp = { x: 100.0, y: 200.0 }
  let r = 100.0
  in
  Render.empty
   *> Render.color Render.white
   *> background assets
   *> Player.render assets p
   *> Render.all (Thing.draw assets) things
   *> Render.printf ("Score: " ++ Int.to_string score) 0.0 0.0 300.0

def draw_menu ::=
    Render.printf "Best Boye" 0.0 0.0 300.0
      *> Render.printf "Press Space to start" 0.0 15.0 300.0

def background : Array Image -> Render : assets =
  let img = Array.index_unsafe assets Asset.tile
  let size = Image.width img
  let needed_x = Real.floor (~Render.width / size)
  let needed_y = Real.floor (~Render.height / size)
  in
  Array.range 0 needed_x
    # Render.all (\x ->
      Array.range 0 needed_y
        # Render.all (\y ->
            Render.image { x: size * x + size / 2, y: size * y + size / 2, r: 0.0, s: 1.0 } img
        )
    )

def render
