mod Main

type State = { x: Int, p : Player, balls : Array Ball, score : Int, boxes : Array Box, assets: Array Image, full_boxes : Array Ball }
type Input = { left: Bool, right: Bool, up: Bool, down: Bool }

def spy : a -> a := foreign -[[
    function(x)
        print(x)
        return x
    end
]]-

def init : Int -> State : _ =
  { x: 2
  , p: Player.new
  , score: 0
  , balls: []
  , boxes: []
  , assets: [ Asset.image "assets/shoe1.png" ]
  , full_boxes: []
  }

def update : Real -> Input -> State -> State : dt input { p, x, balls, score, boxes, assets, full_boxes } =
  let new_ball = Spawner.outside_screen Unit.unit 
  let new_box = Spawner.outside_screen Unit.unit 
  let full_boxes = full_boxes
      # Array.concat
        (balls
          # Array.filter
            (\{ pos: bpos, dir: _ } ->
                Array.any
                  (\{ pos: xpos, dir: _ } -> (Vec.dist xpos bpos) < Box.rad + Ball.rad)
                  boxes
            )
        )
      # spy
  in
  { p: Player.update dt input p
  , x
  , balls: balls
              # Array.filter (\b@{pos, dir: _ } ->
                  Ball.is_inside_screen b
                  && !(Array.any
                        (\{ pos: xpos, dir: _ } -> (Vec.dist xpos pos) < Box.rad + Ball.rad)
                        boxes
                      )
              )
              # Array.map (Ball.update dt)
              # Array.append new_ball
  , score: score + 1
  , boxes: boxes
              # Array.filter (\b@{ pos, dir: _ } -> 
                  Ball.is_inside_screen b
                  && !(Array.any
                        (\{ pos: xpos, dir: _ } -> (Vec.dist xpos pos) < Box.rad + Ball.rad)
                        balls
                        )
                  )
              # Array.map (Box.update dt)
              # Array.append new_box
  , assets
  , full_boxes
  }


def draw
: State -> Render
: { p: p@{ p: xx }, balls, score, boxes, assets, full_boxes } =
  let pp = { x: 100.0, y: 200.0 }
  let r = 100.0
  in
  Render.empty
   *> Render.color (Bool.iff (Circle.hit { p: xx, r: Player.radius } { p: pp, r }) Render.red Render.white)
   *> Player.render p
   *> Render.all (Render.image { x: 100.0, y: 100.0, r: 0.0, s: 1.0 }) assets
   *> Render.circle pp r
   *> Render.printf ("Score: " ++ Int.to_string score) 0.0 0.0 300.0
   *> Render.all (Ball.draw_full) full_boxes
   *> Render.all (Ball.draw) balls
   *> Render.all (Box.draw) boxes
