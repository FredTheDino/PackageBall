mod Thing

enum Thing =
  Shoe { pos : Vec, vel : Vec }
  | Box { pos : Vec, vel : Vec }
  | Full { pos : Vec }

def pos
: Thing -> Vec
: x
= match x
  with Thing:Shoe { pos, vel: _ } -> pos
  with Thing:Box { pos, vel: _ } -> pos
  with Thing:Full { pos } -> pos
  end

def rad
: Thing -> Real
: x
= match x
  with Thing:Shoe _ -> 20.0
  with Thing:Box _ -> 30.0
  with Thing:Full _ -> 30.0
  end

def color
: Thing -> Color
: x
= match x
  with Thing:Shoe _ -> Render.red
  with Thing:Box _ -> Render.blue
  with Thing:Full _ -> Render.green
  end

def asset
: Thing -> Int
: x
= match x
  with Thing:Shoe _ -> Asset.shoe1
  with Thing:Box _ -> Asset.box_open
  with Thing:Full _ -> Asset.box_closed
  end

def is_inside_screen : Thing -> Bool : thing =
    let { x, y } = pos thing
    let margin = rad thing
    let height = margin + Render.height Unit.unit
    let width = margin + Render.width Unit.unit
    in
    ((`margin) <= x)
    && (x <= width)
    && ((`margin) <= y) 
    && (y <= height)

def update : Real -> Player -> Thing -> Thing : dt player thing = 
  let r = rad thing
  let player_pos = Player.pos player
  in
  match thing
  with Thing:Shoe { pos, vel } -> 
       Thing:Shoe
         { pos: vel # Vec.mul dt # Vec.add pos
         , vel: 
              Bool.iff
                (Circle.hit { p: player_pos, r: Player.rad } { p: pos, r })
                (Vec.sub pos player_pos # Vec.normalize)
                (vel)
         }
  with Thing:Box { pos, vel } -> 
       Thing:Box
         { pos: vel # Vec.mul dt # Vec.add pos
         , vel: 
              Bool.iff
                (Circle.hit { p: player_pos, r: Player.rad } { p: pos, r })
                (Vec.sub pos player_pos # Vec.normalize)
                (vel)
         }
  with Thing:Full x -> Thing:Full x
  end

def draw
: Array Image -> Thing -> Render
: assets thing 
= let
     { x, y } = pos thing
   in
   Render.color Render.white
      *> Render.image { x, y, r: 0.0, s: 0.2 } (Array.index_unsafe assets (asset thing))
   -- Render.color (color thing)
   --  *> Render.circle (pos thing) (rad thing)
   --  *> Render.color Render.white

def spawn_box
: Unit -> Thing
: _
=
    let height = Render.height Unit.unit
    let width = Render.width Unit.unit
    let xoffset = Bool.iff (Math.random Unit.unit < 0.5) 0.0 width
    let yoffset = Bool.iff (Math.random Unit.unit < 0.5) 0.0 height
    let x = Math.random Unit.unit * width + xoffset
    let y = Math.random Unit.unit * height + yoffset
    let pos = 
        Bool.iff (Math.random Unit.unit < 0.5)
            { x, y: yoffset }
            { x: xoffset, y }
    let dirt = { x: Math.random Unit.unit * width, y: Math.random Unit.unit * height }
    let vel = Vec.normalize (Vec.sub dirt pos) # Vec.mul (Math.random Unit.unit * 100.0 + 100.0)
    in
    Thing:Box (Bool.iff (Math.random Unit.unit < 0.5)
        { pos: { x: x, y: yoffset }, vel }
        { pos: { x: xoffset, y }, vel }
    )

def spawn_shoe
: Unit -> Thing
: _
=
    let height = Render.height Unit.unit
    let width = Render.width Unit.unit
    let xoffset = Bool.iff (Math.random Unit.unit < 0.5) 0.0 width
    let yoffset = Bool.iff (Math.random Unit.unit < 0.5) 0.0 height
    let x = Math.random Unit.unit * width + xoffset
    let y = Math.random Unit.unit * height + yoffset
    let pos = 
        Bool.iff (Math.random Unit.unit < 0.5)
            { x, y: yoffset }
            { x: xoffset, y }
    let dirt = { x: Math.random Unit.unit * width, y: Math.random Unit.unit * height }
    let vel = Vec.normalize (Vec.sub dirt pos) # Vec.mul (Math.random Unit.unit * 100.0 + 100.0)
    in
    Thing:Shoe ( Bool.iff (Math.random Unit.unit < 0.5)
        { pos: { x: x, y: yoffset }, vel }
        { pos: { x: xoffset, y }, vel }
      )
