mod Thing

enum Thing =
  Shoe { pos : Vec, vel : Vec, img : Int }
  | Box { pos : Vec, vel : Vec }
  | Full { pos : Vec }

def pos
: Thing -> Vec
: x
= match x
  with Thing:Shoe { pos, vel: _, img: _ } -> pos
  with Thing:Box { pos, vel: _ } -> pos
  with Thing:Full { pos } -> pos
  end

def rad
: Thing -> Real
: x
= match x
  with Thing:Shoe _ -> 20.0
  with Thing:Box _ -> 30.0
  with Thing:Full _ -> 30.0
  end

def color
: Thing -> Color
: x
= match x
  with Thing:Shoe _ -> Render.red
  with Thing:Box _ -> Render.blue
  with Thing:Full _ -> Render.green
  end

def asset
: Thing -> Int
: x
= match x
  with Thing:Shoe { pos: _, vel: _, img } -> img
  with Thing:Box _ -> Asset.box_open
  with Thing:Full _ -> Asset.box_closed
  end

def is_full
: Thing -> Bool
: x
= match x
  with Thing:Shoe _ -> false
  with Thing:Box _ -> false
  with Thing:Full _ -> true
  end


def is_inside_screen : Thing -> Bool : thing =
    let { x, y } = pos thing
    let margin = 2.0 * rad thing
    let height = margin + Render.height Unit.unit
    let width = margin + Render.width Unit.unit
    in
    ((`margin) <= x)
    && (x <= width + margin)
    && ((`margin) <= y) 
    && (y <= height + margin)


def player_bounce
: Player -> Vec -> Vec -> Vec
: player p vel
=
  let player_pos = Player.pos player
  let normal = Vec.sub p player_pos # Vec.normalize
  in Vec.mul ((Vec.dot normal (Player.vel player)) # Math.max 0.0 # Preamble._add 20.0) normal

def hit_another_thing : Thing -> Thing -> Bool : a b =
  ((F.on Vec.dist pos a b) < F.on Preamble._add rad a b)
  && (0.5 < (F.on Vec.dist pos a b))

def update : Real -> Player -> Array Thing -> Thing -> Maybe Thing : dt player things thing = 
  let r = rad thing
  let player_pos = Player.pos player
  in
  match is_inside_screen thing
  with false -> let _ = Main.spy "ABC" in (Maybe:Nothing)
  with true -> 
  match thing
    with Thing:Shoe { pos, vel, img } -> 
         match Array.find (hit_another_thing thing) things
          with Maybe:Just _ -> (Maybe:Nothing)
          with Maybe:Nothing -> 
             Maybe:Just
              (Thing:Shoe
               { pos: vel # Vec.mul dt # Vec.add pos
               , vel: 
                    Bool.iff
                      (Circle.hit { p: player_pos, r: Player.rad } { p: pos, r })
                      (player_bounce player pos vel)
                      (vel)
               , img
               }
              )
          end
    with Thing:Box { pos, vel } -> 
       match Array.find (hit_another_thing thing) things
       with Maybe:Just (Thing:Shoe _) -> Maybe:Just (Thing:Full { pos })
       with Maybe:Just _ -> (Maybe:Nothing)
       with Maybe:Nothing -> 
           Maybe:Just
           (Thing:Box
             { pos: vel # Vec.mul dt # Vec.add pos
             , vel: 
                  Bool.iff
                    (Circle.hit { p: player_pos, r: Player.rad } { p: pos, r })
                    (player_bounce player pos vel)
                    (vel)
             }
            )
        end
    with Thing:Full x ->
       Maybe:Just (Thing:Full x)
  end
  end

def draw
: Array Image -> Thing -> Render
: assets thing 
= let
     { x, y } = pos thing
   in
   Render.color Render.white
      *> Render.image { x, y, r: 0.0, s: 0.2 } (Array.index_unsafe assets (asset thing))
   -- Render.color (color thing)
   --  *> Render.circle (pos thing) (rad thing)
   --  *> Render.color Render.white


def min_speed ::= 7.0
def ran_speed ::= 7.0

def random_speed :: _ = Math.random Unit.unit * ran_speed + min_speed

def spawn_box
: Unit -> Thing
: _
=
    let height = Render.height Unit.unit
    let width = Render.width Unit.unit
    let xoffset = Bool.iff (Math.random Unit.unit < 0.5) 0.0 width
    let yoffset = Bool.iff (Math.random Unit.unit < 0.5) 0.0 height
    let x = Math.random Unit.unit * width + xoffset
    let y = Math.random Unit.unit * height + yoffset
    let pos = 
        Bool.iff (Math.random Unit.unit < 0.5)
            { x, y: yoffset }
            { x: xoffset, y }
    let dirt = { x: Math.random Unit.unit * width, y: Math.random Unit.unit * height }
    let vel = Vec.normalize (Vec.sub dirt pos) # Vec.mul (random_speed Unit.unit)
    in
    Thing:Box (Bool.iff (Math.random Unit.unit < 0.5)
        { pos: { x: x, y: yoffset }, vel }
        { pos: { x: xoffset, y }, vel }
    )

def spawn_shoe
: Unit -> Thing
: _
=
    let height = Render.height Unit.unit
    let width = Render.width Unit.unit
    let xoffset = Bool.iff (Math.random Unit.unit < 0.5) 0.0 width
    let yoffset = Bool.iff (Math.random Unit.unit < 0.5) 0.0 height
    let x = Math.random Unit.unit * width + xoffset
    let y = Math.random Unit.unit * height + yoffset
    let pos = 
        Bool.iff (Math.random Unit.unit < 0.5)
            { x, y: yoffset }
            { x: xoffset, y }
    let dirt = { x: Math.random Unit.unit * width, y: Math.random Unit.unit * height }
    let vel = Vec.normalize (Vec.sub dirt pos) # Vec.mul (random_speed Unit.unit)
    let img = Math.random_int Asset.shoe1 Asset.shoe3
    in
    Thing:Shoe ( Bool.iff (Math.random Unit.unit < 0.5)
        { pos: { x: x, y: yoffset }, vel, img }
        { pos: { x: xoffset, y }, vel, img }
      )
