mod Thing

enum Thing =
  Shoe { pos : Vec, vel : Vec, angle: Real, img : Int }
  | Box { pos : Vec, vel : Vec }
  | Full { pos : Vec }

def pos
: Thing -> Vec
: x
= match x
  with Thing:Shoe { pos, angle: _, vel: _, img: _ } -> pos
  with Thing:Box { pos, vel: _ } -> pos
  with Thing:Full { pos } -> pos
  end

def angle
: Thing -> Real
: x
= match x
  with Thing:Shoe { pos: _, angle, vel: _, img: _ } -> angle
  with _ -> 0.0
  end


def rad
: Thing -> Real
: x
= match x
  with Thing:Shoe _ -> 20.0
  with Thing:Box _ -> 30.0
  with Thing:Full _ -> 30.0
  end

def color
: Thing -> Color
: x
= match x
  with Thing:Shoe _ -> Render.red
  with Thing:Box _ -> Render.blue
  with Thing:Full _ -> Render.green
  end

def asset
: Thing -> Int
: x
= match x
  with Thing:Shoe { pos: _, vel: _, angle: _, img } -> img
  with Thing:Box _ -> Asset.box_open
  with Thing:Full _ -> Asset.box_closed
  end

def is_full
: Thing -> Bool
: x
= match x
  with Thing:Shoe _ -> false
  with Thing:Box _ -> false
  with Thing:Full _ -> true
  end

def is_box
: Thing -> Bool
: x
= match x with Thing:Box _ -> true with _ -> false end


def is_inside_screen : Thing -> Bool : thing =
    let { x, y } = pos thing
    let margin = 2.0 * rad thing
    let height = margin + Render.height Unit.unit
    let width = margin + Render.width Unit.unit
    in
    ((`margin) <= x)
    && (x <= width + margin)
    && ((`margin) <= y) 
    && (y <= height + margin)


def player_bounce
: Bool -> Player -> Vec -> Real -> Vec -> Vec
: hit player p r vel
=
  let player_pos = Player.pos player
  in
  Bool.iff
    (hit && Circle.hit { p: player_pos, r: Player.rad } { p, r })
      (let normal = Vec.sub p player_pos # Vec.normalize
       in Vec.mul (((Vec.dot normal (Player.vel player)) # Math.max 0.0 # Preamble._add 20.0) + 100.0 + Vec.len vel) normal
      )
      (vel)

def hit_another_thing : Thing -> Thing -> Bool : a b =
  ((F.on Vec.dist pos a b) < F.on Preamble._add rad a b)
  && (0.5 < (F.on Vec.dist pos a b))

def bounce
: Thing -> Thing -> Vec -> Vec
: other self vel = 
  let n = F.on Vec.sub pos self other # Vec.normalize
  in 
    Bool.iff
      (0.0 < Vec.dot n vel)
      (Vec.vec 0.0 0.0)
      (vel)

def bounce_inside
: Real -> Vec -> Vec -> Vec
: margin { x, y } { x: vx, y: vy } =
  let hix = (Render.width Unit.unit - margin)
  let hiy = (Render.height Unit.unit - margin)
  let lox = margin
  let loy = margin
  in
  { x: vx * (Bool.iff
          (((lox < x) && (vx < 0.0))
          || ((0.0 < vx) && (x < hix)))
          1.0
          (`0.4)
        )
  , y: vy * (Bool.iff
          (((loy < y) && (vy < 0.0))
          || ((0.0 < vy) && (y < hiy)))
          1.0
          (`0.4)
        )
  }

def update : Real -> Player -> Bool -> Array Thing -> Thing -> Maybe Thing : dt player hit things thing = 
  let r = rad thing
  let player_pos = Player.pos player
  in
  match is_inside_screen thing
  with false -> (Maybe:Nothing)
  with true -> 
  match thing
    with Thing:Shoe { pos, vel, img, angle } -> 
         match Array.find (hit_another_thing thing) things
          with Maybe:Just _ -> (Maybe:Nothing)
          with Maybe:Nothing ->
             Maybe:Just
              (Thing:Shoe
               { pos: vel # Vec.mul dt # Vec.add pos
               , vel: player_bounce hit player pos r vel
               , img
               , angle: angle + dt * Vec.len vel
               }
              )
          end
    with Thing:Box { pos, vel } -> 
       match Array.find (hit_another_thing thing) things
       with Maybe:Just (Thing:Shoe _) -> Maybe:Just (Thing:Full { pos })
       with Maybe:Just t@(Thing:Box _) -> Maybe:Just (Thing:Box { pos, vel: Vec.vec 0.0 0.0 })
       with Maybe:Just t@(Thing:Full _) -> Maybe:Just (Thing:Box { pos, vel: Vec.vec 0.0 0.0 })
       with Maybe:Just _ -> (Maybe:Nothing)
       with Maybe:Nothing -> 
           Maybe:Just
           (Thing:Box
             { pos: vel
                    # Vec.mul dt
                    # Vec.add pos
             , vel: vel # player_bounce hit player pos r # bounce_inside r pos
             }
           )
        end
    with Thing:Full x ->
       Maybe:Just (Thing:Full x)
  end
  end

def draw
: Array Image -> Thing -> Render
: assets thing 
= let { x, y } = pos thing
  let img = Array.index_unsafe assets (asset thing)
  let s = 2.0 * rad thing / Image.width img
  let r = 0.1 * angle thing
  in
  Render.color Render.white *> Render.image { x, y, r, s } img


def min_speed ::= 50.0
def ran_speed ::= 80.0

def random_speed :: _ = Math.random Unit.unit * ran_speed + min_speed

def spawn_box
: Unit -> Thing
: _
=
    let height = Render.height Unit.unit
    let width = Render.width Unit.unit
    let pos = 
        Bool.iff (Math.random Unit.unit < 0.5)
            { x: Math.random Unit.unit * width, y: Bool.iff (Math.random Unit.unit < 0.5) 0.0 height }
            { x: Bool.iff (Math.random Unit.unit < 0.5) 0.0 width, y: Math.random Unit.unit * height }
    let dirt = { x: Math.random Unit.unit * width, y: Math.random Unit.unit * height }
    let vel = Vec.normalize (Vec.sub dirt pos) # Vec.mul (random_speed Unit.unit)
    in
    Thing:Box { pos, vel }

def spawn_shoe
: Unit -> Thing
: _
=
    let height = Render.height Unit.unit
    let width = Render.width Unit.unit
    let pos = 
        Bool.iff (Math.random Unit.unit < 0.5)
            { x: Math.random Unit.unit * width, y: Bool.iff (Math.random Unit.unit < 0.5) 0.0 height }
            { x: Bool.iff (Math.random Unit.unit < 0.5) 0.0 width, y: Math.random Unit.unit * height }
    let dirt = { x: Math.random Unit.unit * width, y: Math.random Unit.unit * height }
    let vel = Vec.normalize (Vec.sub dirt pos) # Vec.mul (random_speed Unit.unit)
    let img = Math.random_int Asset.shoe1 Asset.shoe3
    in
    Thing:Shoe { pos, vel, img, angle: 0.0 }
