mod Array

type Array a = foreign

def head
  : Array a -> Maybe a
  := foreign -[[
    function(xs)
      local x = xs[1]
      if x == nil then
        return Sylt.Enum.new("Nothing", nil)
      else
        return Sylt.Enum.new("Just", x)
      end
    end
  ]]-

def last
  : Array a -> Maybe a
  := foreign -[[
    function(xs)
      local x = xs[#xs]
      if x == nil then
        return Sylt.Enum.new("Nothing", nil)
      else
        return Sylt.Enum.new("Just", x)
      end
    end
  ]]-


def empty
  : Array a
  := foreign -[[ Sylt.Array.new({}) ]]-

def singleton
  : a -> Array a
  := foreign -[[ function(a) return Sylt.Array.new({a}) end ]]-

def append :  a -> Array a -> Array a
  : x xs = concat xs (singleton x)

def prepend :  a -> Array a -> Array a
  : x xs = concat (singleton x) xs

def concat
  : Array a -> Array a -> Array a
  := foreign -[[
  function(a) return function(b)
    local c = Sylt.Array.new({})
    for _, x in pairs(a) do
      table.insert(c, x)
    end
    for _, x in pairs(b) do
      table.insert(c, x)
    end
    return c
  end end
]]-

def foldl
  : (a -> b -> b) -> b -> Array a -> b
  := foreign -[[
  function(f) return function(s) return function(xs)
    local b = s
    for _, a in ipairs(xs) do
      b = f(a)(b)
    end
    return b
  end end end
]]-

def tostring
  : a -> Str
  := foreign -[[ tostring ]]-

def map
  : (a -> b) -> Array a -> Array b
  := foreign -[[
  function(f) return function(a)
    local b = Sylt.Array.new({})
    for _, x in pairs(a) do
      table.insert(b, f(x))
    end
    return b
  end end
]]-

def filter
  : (a -> Bool) -> Array a -> Array a
  := foreign -[[
  function(f) return function(a)
    local b = Sylt.Array.new({})
    for _, x in pairs(a) do
      if f(x) then table.insert(b, x) end
    end
    return b
  end end
]]-

def filter_map
  : (a -> Maybe b) -> Array a -> Array b
  := foreign -[[
  function(f) return function(a)
    local b = Sylt.Array.new({})
    for _, x in pairs(a) do
      local y = f(x);
      if y[1] ~= "Nothing" then table.insert(b, y[2]) end
    end
    return b
  end end
]]-

def find
  : (a -> Bool) -> Array a -> Maybe a
  := foreign -[[
  function(f) return function(a)
    for _, x in pairs(a) do
      if f(x) then
        return Sylt.Enum.new("Just", x)
      end
    end
    return Sylt.Enum.new("Nothing", nil)
  end end
]]-

def count_if
  : (a -> Bool) -> Array a -> Int
  : f xs = xs # map (\x -> x # f # Bool.to_int) # foldl Preamble._add 0

def flatten : Array (Array a) -> Array a := foldl ' concat ' empty

def any : (a -> Bool) -> Array a -> Bool : f xs = find f xs # Maybe.is_just
def all : (a -> Bool) -> Array a -> Bool : f xs = !(any (\x -> !(f x)) xs)

def index_unsafe : Array a -> Int -> a := foreign -[[
    function(a) return function(i) return a[i+1] end end
]]-

def range
  : Int -> Int -> Array Int
  := foreign -[[
  function(from) return function(to)
    local a = Sylt.Array.new({})
    for i=from,to do
      table.insert(a, i)
    end
    return a
  end end
]]-

def size
  : Array a -> Int
  := foreign -[[
      function(a)
          return #a
      end
]]-
